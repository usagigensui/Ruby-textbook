# 4.3.2

# eachメソッドは、配列の要素を最初から順番に取り出すことができる
nambers = [1, 2, 3, 4]
sum = 0
nambers.each do |n|
  sum += n
end
sum #=> 10
# 上記のdoからendまでをブロックという
# |n|のnはブロック引数と呼ばれ、eachから渡された配列の要素が入る
# ブロックの内部では自由にRubyのコードを書くことができる

# 4.3.3

a = [1, 2, 3, 1, 2, 3]
# 配列から値が2の要素を削除する
a.delete(2)
a #=> [1, 3, 1, 3]

# deleteメソッドは引数に完全一致する要素しか削除できない
# 例えば奇数だけを削除したい場合は、deleteメソッドでは実現できない

# delete_ifメソッドは、配列の要素をひとつずつ取り出し、ブロックの戻り値が真であればその要素を配列から削除する
a = [1, 2, 3, 1, 2, 3]
# 配列から値が奇数の要素を削除する
a.delete_if do |n|
  # odd?メソッドは数値が奇数の場合にtrueを返す
  n.odd?
end
a #=> [2, 2]

# 4.3.4

nambers = [1, 2, 3, 4]
sum = 0
nambers.each do |n|
  sum_value = n.even? n * 10 : n
  sum += sum_value
end
sum #=> 64
# sum_valueはブロック内で初めて登場した変数
# このような変数のスコープ(有効範囲)はブロック内部のみとなり、ブロック外で使用するとエラーする
# sumはブロック外で作成されたローカル変数のため、ブロックの内部でも参照できる

nambers = [1, 2, 3, 4]
sum = 0
sum_value = 100
nambers.each do |sum_value|
  sum += sum_value # ブロック引数のsum_valueが優先される
end
sum #=> 10
# ブロック引数の名前をブロック外の変数の名前と同じにすると、ブロック内ではブロック引数の値が優先される
# このように名前の重複で他のメソッドや変数が参照できなくなることをシャドーイングという
# ただし、可読性を下げ、思わぬ不具合の原因にもなるので、基本的に名前の重複は避けること

# 4.3.5

# do...endの代わりに{}で囲むことでもブロックは作れる
nambers = [1, 2, 3, 4]
sum = 0
nambers.each { |n| sum += n }
sum #=> 10