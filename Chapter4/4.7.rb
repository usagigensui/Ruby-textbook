# 4.7.1

# 配列[位置, 取得する長さ]
# 添え字を2つ使うと、氏江時の位置と取得する長さを指定できる
a = [1, 2, 3, 4]
a[1, 3] #=> [2, 3, 4]

# values_atメソッドを使うと、取得したい要素の添え字を複数指定できる
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) #=> [1, 3, 5]

# 「配列の長さ-1」を指定すれば、最後の要素を取得できる
a = [1, 2, 3]
a[a.size - 1] #=> 3
# 添え字に負の値を指定することもできる
a[-1]    #=> 3
a[-2]    #=> 2
a[-2, 2] #=> 2, 3
# lastメソッドで配列の最後の値を取得する
a.last #=> 3
# 引数に0以上の数値を渡すと最後のn個の要素を取得する
a.last(2) #=> [2, 3
# firstメソッドは配列の最初の値を取得する
a.first    #=> 1
a.first(2) #=> [1, 2]

# 4.7.2

# 値を変更する場合も負の添え字が使えるが、元の大きさを超える添え字を指定するとエラーする
a = [1, 2, 3]
a[-3] = -10 #=> [-10, 2, 3]

# 開始位置と長さを指定して要素を置き換えることもできる
a = [1, 2, 3, 4, 5]
# 2つめから3要素分を100で置き換える
a[1, 3] = 100
a #=> [1, 100, 5]

# <<だけでなく、pushメソッドを使っても要素を追加できる
a = []
a.push(1)    #=> [1]
a.push(2, 3) #=> [1, 2, 3]

# 指定した値に一致する要素を削除する場合はdeleteメソッドを使う
a = [1, 2, 3, 1, 2, 3]
# 値が2である要素を削除する(削除した値が戻り値)
a.delete(2) #=> 2
a           #=> [1, 3, 1, 3]
# 存在しない値を指定するとnilが返る
a.delete(5) #=> nil
a           #=> [1, 3, 1, 3]

# 4.7.3

# concatメソッド(破壊的メソッド)で配列を連結すると、元の配列が変更される
a = [1]
b = [2, 3]
a.concat(b) #=> [1, 2, 3]
a           #=> [1, 2, 3]
b           #=> [2, 3]

# +を使って配列を連結すると、新しい配列を作成するので、元の配列は変更されない
a = [1]
b = [2, 3]
a + b #=> [1, 2, 3]
a     #=> [1]
b     #=> [2, 3]

# 4.7.4

# |で配列の和集合を求めることができる
a = [1, 2, 3]
b = [3, 4, 5]
a | b #=> [1, 2, 3, 4, 5]

# -で配列の差集合をも止めることができる
a = [1, 2, 3]
b = [3, 4, 5]
a - b #=> [1, 2]

# &で配列の積集合を求めることができる
a = [1, 2, 3]
b = [3, 4, 5]
a & b #=> [3]

# Setクラスでより効率的に集合を扱うことができる
require 'set'
a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
a | b #=> #<Set: (1, 2, 3, 4, 5)>
a - b #=> #<Set: (1, 2)>
a & b #=> #<Set: (3)>

# 4.7.5

# 多重代入では左辺の変数よりも右辺の個数が多い場合ははみ出した値が切り捨てられるが、
# 左辺の変数に*を付けると、残りの全要素を配列として受け取れる
e, *f = 100, 200, 300
e #=> 100
f #=> [200, 300]

# 4.7.6

# pushメソッドで配列を追加すると、２つの要素ではなく配列として追加される
a = []
b = [2, 3]
a.push(1) #=> [1]
a.push(b) #=> [1, [2, 3]]

# 配列を複数の引数として渡したい場合は、配列の前に*を置く(splat展開)
a = []
b = [2, 3]
a.push(1) #=> [1]
a.push(*b) #=> [1, 2, 3]

# 4.7.7

# pushメソッドのように、個数に制限のない引数のことを可変長引数という
# 自分で定義するメソッドで可変長引数を使う場合は、引数名の手前に*をつける
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end
greeting('田中さん')                       #=> "田中さん、こんにちは！"
greeting('田中さん', '鈴木さん')            #=> "田中さんと鈴木さん、こんにちは！"
greeting('田中さん', '鈴木さん', '佐藤さん') #=> "田中さんと鈴木さんと佐藤さん、こんにちは！"

# 4.7.8

a = [1, 2, 3]
# []の中にそのまま配列を置くと、配列の配列になる
[a] #=> [[1, 2, 3]]
# *付きで配列を置くと、展開されて別々の要素になる(splat展開)
[*a] #=> [1, 2, 3]

# 別の配列を要素の一部として新しい配列が作れる
a = [1, 2, 3]
[-1, 0, *a, 4, 5] #=> [-1, 0, 1, 2, 3, 4, 5]
# *ではなく+でも同じことができる
[-1, 0] + a + [4, 5] #=> [-1, 0, 1, 2, 3, 4, 5]

# 4.7.9

[1, 2, 3] == [1, 2, 3]    #=> true
[1, 2, 3] == [1, 2, 4]    #=> false
[1, 2, 3] == [1, 2]       #=> false
[1, 2, 3] == [1, 2, 3, 4] #=> false

# 4.7.10

# []で文字列の配列を作成する
['apple', 'melon', 'orange'] #=> ["apple", "melon", "orange"]
# %wで文字列の配列を作成する(!で囲む場合)
%w!apple melon orange! #=> ["apple", "melon", "orange"]
# %wで文字列の配列を作成する(丸かっこで囲む場合)
%w(apple melon orange) #=> ["apple", "melon", "orange"]
# 空白文字(スペースや改行)が連続した場合も1つの区切り文字と見なされる
%w(
  apple
  melon
  orange
)
#=> ["apple", "melon", "orange"]

# 4.7.11

# charsメソッドは文字列中の１文字１文字を配列の要素に分解する
'Ruby'.chars #=> ["R", "u", "b", "y"]

# splitメソッドは引数で渡した区切り文字で文字列を配列に分解する
'Ruby,Java,Perl,PHP'.split(',') #=> ["Ruby", "Java", "Perl", "PHP"]

# 4.7.12

# 以下のコードはa = []と同じ
a = Array.new

# 要素が5つの配列を作成する
a = Array.new(5)
a #=> [nil, nil, nil, nil, nil]

# 要素が5つで0を初期値とする配列を作成する
a = Array.new(5, 0)
a #=> [0, 0, 0, 0, 0]

# 要素数が10で、1, 2, 3, 1, 2, 3, ...と繰り返す配列を作る
a = Array.new(10) { |n| n % 3 + 1 }
a #=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]

# 4.7.13

# 要素が5つで'default'を初期値とする配列を作成する
a = Array.new(5, 'default')
a #=> ["default", "default", "default", "default", "default"]

# 1番目の要素を取得する
str = a[0]
str #=> "default"

# 1番目の要素を大文字に変換する(破壊的変更)
str.upcase!
str #=> "DEFAULT"
# 配列の要素すべてが大文字に変わってしまう
a #=> ["DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT"]
# これは配列の全要素が同じ文字列オブジェクトを参照しているために起こる

# ブロックを使ってブロックの戻り値を初期値とすることで避けられる
a = Array.new(5) { 'default' }
a #=> ["default", "default", "default", "default", "default"]
str = a[0]
str #=> "default"
str.upcase!
str #=> "DEFAULT"
a #=> ["DEFAULT", "default", "default", "default", "default"]

# 4.7.14

# 文字列(String)はミュータブル(mutable)なクラスなので破壊的な変更が可能
# 数値(IntegerやFloat)、シンボル(Symbol)、true/false、nilはインミュータブル(immutable)なクラスなので破壊的な変更が適用できない
# ミュータブル⇒「変更可能な」　インミュータブル⇒「変更できない、不変の」

# Column

# 文字列は配列とは無関係なオブジェクトだが、[]や<<を使って操作できる

a = 'abcde'
# 3文字目を取得する
a[2] #=> "c"
# 2文字目から3文字文を取得する
a[1, 3] #=> "bcd"
# 最後の1文字を取得する
a[-1] #=> "e"
# 1文字目を"X"に置き換える
a[0] = 'X'
a #=> "Xbcde"
# 2文字目から3文字分を"Y"で置き換える
a[1, 3] = 'Y'
a #=> "Xye"
# 末尾に"PQR"を連結する
a << 'PQR'
a #=> "XyePQR"